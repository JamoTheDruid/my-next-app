// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  // NOTE: Per your setup, Prisma loads connection info via prisma.config.ts (not `url = env(...)`).
}

/**
 * =========================================================
 * AUTH / IDENTITY
 * =========================================================
 */

model User {
  id           String     @id @default(cuid())
  email        String     @unique
  passwordHash String?    // Argon2 hash (nullable for Google-only accounts)
  provider     String?    // "google" etc.
  providerId   String?
  name         String?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  roles        UserRole[]
  customers    CustomerUser[]
  sessions     Session[]

  // Accounting (who created a journal entry)
  journalEntries JournalEntry[]

  @@index([email])
  @@unique([provider, providerId])
}

model Session {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  revokedAt   DateTime?

  ipAddress   String?
  userAgent   String?
  lastSeenAt  DateTime?

  @@index([userId])
  @@index([expiresAt])
  @@index([revokedAt])
}

enum RoleKey {
  ADMIN
  MANAGER
  EMPLOYEE
  CUSTOMER
  GUEST
}

model Role {
  id        String    @id @default(cuid())
  key       RoleKey   @unique
  name      String
  system    Boolean   @default(false)
  createdAt DateTime  @default(now())

  users     UserRole[]
}

model UserRole {
  userId     String
  roleId     String
  isPrimary  Boolean   @default(false)
  createdAt  DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)

  @@id([userId, roleId])
  @@index([roleId])
  @@index([userId])
}

/**
 * =========================================================
 * BUSINESS ENTITIES
 * =========================================================
 */

enum CustomerStatus {
  LEAD
  ACTIVE
  INACTIVE
  ARCHIVED
}

enum CustomerUserRelation {
  OWNER
  MEMBER
  BILLING
}

model Customer {
  id          String         @id @default(cuid())
  name        String
  email       String?        @unique
  telephone   String?
  addressRaw  String?
  status      CustomerStatus @default(ACTIVE)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  properties  Property[]
  users       CustomerUser[]
  projects    Project[]
  finances    Finance[]

  // Accounting: optional linkage for reporting
  journalEntries JournalEntry[]

  @@index([email])
  @@index([status])
}

model CustomerUser {
  customerId String
  userId     String
  relation   CustomerUserRelation @default(OWNER)
  isPrimary  Boolean              @default(true)
  createdAt  DateTime             @default(now())

  customer   Customer             @relation(fields: [customerId], references: [id], onDelete: Cascade)
  user       User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([customerId, userId])
  @@index([userId])
  @@index([customerId])
}

/**
 * =========================================================
 * OPERATIONS
 * =========================================================
 */

model Property {
  id          String    @id @default(cuid())
  address     String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId  String

  files       File[]
  finances    Finance[]

  // Accounting: optional linkage for reporting
  journalEntries JournalEntry[]

  @@index([customerId])
}

model Project {
  id          String    @id @default(cuid())
  name        String
  description String?
  startDate   DateTime?
  endDate     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId  String
  finances    Finance[]

  // Accounting: optional linkage for reporting
  journalEntries JournalEntry[]

  @@index([customerId])
}

model Finance {
  id          String    @id @default(cuid())
  type        String
  amount      Float
  date        DateTime
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  customer    Customer  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId  String
  project     Project?  @relation(fields: [projectId], references: [id], onDelete: SetNull)
  projectId   String?
  property    Property? @relation(fields: [propertyId], references: [id], onDelete: SetNull)
  propertyId  String?

  // Accounting: optional linkage if you “post” Finance records to the ledger
  journalEntry JournalEntry?

  @@index([customerId])
}

model File {
  id           String   @id @default(cuid())
  originalName String
  storageKey   String   @unique
  publicUrl    String?
  fileSize     Int?
  mimeType     String?
  createdAt    DateTime @default(now())

  property     Property @relation(fields: [propertyId], references: [id], onDelete: Cascade)
  propertyId   String

  @@index([propertyId])
}

/**
 * =========================================================
 * ACCOUNTING (CANNIBALIZED Account + JournalEntry)
 *
 * Pattern:
 * - Accounts are app-managed (create from UI)
 * - JournalEntry is the business event (append-only)
 * - JournalLine are postings (double-entry: sum of lines = 0)
 * - AccountBalance is an optional snapshot for instant “current status”
 * =========================================================
 */

model Organization {
  id        String   @id @default(cuid())
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  accounts        Account[]
  journalEntries  JournalEntry[]
  journalLines    JournalLine[] 
  accountBalances AccountBalance[]
}

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  EXPENSE
}

enum AccountSubtype {
  // Assets
  CASH
  ACCOUNTS_RECEIVABLE
  PREPAID_EXPENSES
  INVENTORY
  FIXED_ASSETS
  ACCUMULATED_DEPRECIATION
  OTHER_ASSET

  // Liabilities
  ACCOUNTS_PAYABLE
  CREDIT_CARD
  TAX_PAYABLE
  PAYROLL_LIABILITY
  LOANS_PAYABLE
  DEFERRED_REVENUE
  OTHER_LIABILITY

  // Equity
  OWNER_EQUITY
  RETAINED_EARNINGS
  OTHER_EQUITY

  // Revenue
  SERVICE_REVENUE
  OTHER_REVENUE

  // Expenses
  COGS
  PAYROLL_EXPENSE
  RENT
  UTILITIES
  INSURANCE
  FUEL
  MAINTENANCE
  MARKETING
  SOFTWARE
  MEALS
  DEPRECIATION_EXPENSE
  OTHER_EXPENSE
}

model Account {
  id        String @id @default(cuid())

  // Scope accounts to an organization (multi-tenant ready)
  orgId     String
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  name      String
  code      String? // optional but useful for imports/reporting
  type      AccountType
  subtype   AccountSubtype?
  currency  String @default("USD")

  // Rollups (optional)
  parentId  String?
  parent    Account?  @relation("AccountHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children  Account[] @relation("AccountHierarchy")

  isActive  Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lines     JournalLine[]
  balance   AccountBalance?

  @@unique([orgId, code])
  @@index([orgId, type])
  @@index([orgId, subtype])
  @@index([parentId])
}

model JournalEntry {
  id        String   @id @default(cuid())

  orgId     String
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Accounting effective date
  entryDate DateTime

  title     String?
  memo      String?
  reference String? // invoice #, check #, external ref

  // Optional: who created it
  createdById String?
  createdBy   User? @relation(fields: [createdById], references: [id], onDelete: SetNull)

  // Optional: link to business entities for reporting
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: SetNull)

  projectId  String?
  project    Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  propertyId String?
  property   Property? @relation(fields: [propertyId], references: [id], onDelete: SetNull)

  // Optional: link to Finance if you “post” a Finance record into the ledger
  financeId  String? @unique
  finance    Finance? @relation(fields: [financeId], references: [id], onDelete: SetNull)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lines     JournalLine[]

  @@index([orgId, entryDate])
  @@index([orgId, createdAt])
  @@index([orgId, reference])
  @@index([createdById])
  @@index([customerId])
  @@index([projectId])
  @@index([propertyId])
}

model JournalLine {
  id        String @id @default(cuid())

  orgId     String
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  entryId   String
  entry     JournalEntry @relation(fields: [entryId], references: [id], onDelete: Cascade)

  accountId String
  account   Account @relation(fields: [accountId], references: [id], onDelete: Restrict)

  /**
   * Signed integer cents:
   * - debit = positive
   * - credit = negative
   *
   * With this convention:
   * - an entry is balanced when SUM(lines.amountCents) = 0
   * - an account balance is SUM(lines.amountCents) over time
   */
  amountCents BigInt

  description String?
  externalId  String? // plaid txn id / import id / etc

  createdAt DateTime @default(now())

  @@index([orgId, accountId])
  @@index([orgId, entryId])
  @@index([orgId, accountId, createdAt])
  @@index([orgId, accountId, externalId])
}

model AccountBalance {
  // 1:1 with Account
  accountId String @id
  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  orgId     String
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  // Signed cents, same convention as JournalLine.amountCents
  balanceCents BigInt @default(0)

  // Optional bookkeeping for debugging/invalidation
  lastEntryId String?
  updatedAt   DateTime @updatedAt

  @@index([orgId])
}

/**
 * =========================================================
 * ANGI LEADS
 * =========================================================
 */

model AngiLead {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  // basic info
  name          String
  firstName      String
  lastName       String
  email          String
  address        String
  city           String
  stateProvince  String
  postalCode     String

  // phones
  primaryPhone        String
  phoneExt            String?
  secondaryPhone      String?
  secondaryPhoneExt   String?
  primaryMaskedNumber Boolean @default(false)

  // angi identifiers / metadata
  srOid        BigInt
  leadOid      BigInt @unique
  fee          Decimal
  taskName     String
  comments     String
  matchType    String
  leadDescription String
  spEntityId   BigInt
  spCompanyName String
  contactStatus String
  crmKey       String?
  leadSource   String
  trustedFormUrl String?
  automatedContactCompliant Boolean
  automatedContactConsentId String?

  interview AngiInterviewEntry[]
}

model AngiInterviewEntry {
  id        String   @id @default(cuid())
  leadId    String
  lead      AngiLead @relation(fields: [leadId], references: [id], onDelete: Cascade)

  question  String
  answer    String

  @@index([leadId])
}
